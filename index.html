<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Circle Audio Synth</title>
<style>
html, body {margin:0;padding:0;width:100%;height:100%;background:#111;overflow:hidden;}
svg {display:block;width:100%;height:100%;cursor:crosshair;}
.ghost {fill:none;stroke:rgba(255,255,255,0.15);stroke-width:1.5;}
.spinner {fill:none;stroke-width:3;transform-box:fill-box;transform-origin:center;}
@keyframes spin {to{transform:rotate(360deg);}}
</style>
</head>
<body>
<svg id="canvas"></svg>
<script>
const svg = document.getElementById("canvas");
const radius = 60;
const circ = 2*Math.PI*radius;

let currentCircle=null;
let holdStart=null;
let lastSegmentStart=null;
let isSpaceDown=false;
let segments=[];
let rafId=null;
const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
const activeCircles=[];

function randomColor(){return `hsl(${Math.floor(Math.random()*360)},80%,55%)`;}

// Build dash array string
function buildDashArray(segments,liveType,liveDuration,totalDurationMs){
    if(totalDurationMs<=0) return `0 ${circ}`;
    const scale = circ/totalDurationMs;
    const all = segments.slice();
    if(liveDuration>0) all.push({type:liveType,duration:liveDuration});
    if(all.length===0) return `0 ${circ}`;
    const lens=all.map(s=>Math.max(1,Math.round(s.duration*scale)));
    const out=[];
    if(all[0].type==='gap'){ out.push(0,lens[0]); for(let i=1;i<lens.length;i++) out.push(lens[i]);}
    else{for(let i=0;i<lens.length;i++) out.push(lens[i]);}
    return out.join(' ');
}

// Play a note
function playTone(freq,pan,duration){
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    const panner = audioCtx.createStereoPanner();
    osc.type='sine'; osc.frequency.value=freq;
    gainNode.gain.value=0.2; 
    panner.pan.value=pan;
    osc.connect(gainNode); gainNode.connect(panner); panner.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime+duration);
}

// Live preview tick
function startLivePreview(){
    const tick=()=>{
        if(!currentCircle) return;
        const now = performance.now();
        const liveDuration=now-lastSegmentStart;
        const total=now-holdStart;
        const dashArray=buildDashArray(segments,isSpaceDown?'dash':'gap',liveDuration,total);
        currentCircle.setAttribute('stroke-dasharray',dashArray);

        // Live note for currently growing segment
        if(isSpaceDown && liveDuration>0){
            const x=currentCircle._pos.x;
            const y=currentCircle._pos.y;
            const freq=220+(x/window.innerWidth)*880+(Math.random()*20-10);
            const pan=(x/window.innerWidth)*2-1;
            playTone(freq,pan,0.05); // short note
        }

        rafId=requestAnimationFrame(tick);
    };
    rafId=requestAnimationFrame(tick);
}

// Looping audio for completed circles
function loopCircleAudio(circle){
    const totalDuration = circle._holdDuration/1000;
    const scale = circ/circle._holdDuration;
    let t0 = audioCtx.currentTime;
    function scheduleLoop(){
        const tNow = audioCtx.currentTime;
        let t = tNow;
        circle._segments.forEach(seg=>{
            const dur = (seg.duration/1000)*0.2; // speed scaling factor
            if(seg.type==='dash'){
                const freq=220+(circle._pos.x/window.innerWidth)*880+(Math.random()*20-10);
                const pan=(circle._pos.x/window.innerWidth)*2-1;
                playTone(freq,pan,dur);
            }
            t+=dur;
        });
        setTimeout(scheduleLoop, totalDuration*200); // loop faster for scaled-up speed
    }
    scheduleLoop();
}

svg.addEventListener("mousedown",e=>{
    const pt=svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
    const loc=pt.matrixTransform(svg.getScreenCTM().inverse());

    const ghost=document.createElementNS("http://www.w3.org/2000/svg","circle");
    ghost.setAttribute("cx",loc.x); ghost.setAttribute("cy",loc.y); ghost.setAttribute("r",radius);
    ghost.classList.add("ghost"); svg.appendChild(ghost);

    currentCircle=document.createElementNS("http://www.w3.org/2000/svg","circle");
    currentCircle.setAttribute("cx",loc.x); currentCircle.setAttribute("cy",loc.y); currentCircle.setAttribute("r",radius);
    currentCircle.classList.add("spinner"); currentCircle.style.stroke=randomColor();
    currentCircle.setAttribute("stroke-dasharray",`0 ${circ}`);
    currentCircle._pos={x:loc.x,y:loc.y};
    svg.appendChild(currentCircle);

    holdStart=performance.now();
    lastSegmentStart=holdStart;
    segments=[];
    isSpaceDown=false;
    startLivePreview();
});

svg.addEventListener("mouseup",()=>{
    if(!currentCircle) return;
    const now=performance.now();
    segments.push({type:isSpaceDown?'dash':'gap',duration:now-lastSegmentStart});
    const total=now-holdStart;
    const dashArray=buildDashArray(segments,null,0,total);
    currentCircle.setAttribute('stroke-dasharray',dashArray);
    currentCircle.style.animation=`spin 0.6s linear infinite`; // fast spin

    // Store circle for looping audio
    currentCircle._segments=segments.slice();
    currentCircle._holdDuration=total;
    activeCircles.push(currentCircle);
    loopCircleAudio(currentCircle);

    cancelAnimationFrame(rafId);
    currentCircle=null;
    segments=[];
    isSpaceDown=false;
    holdStart=null;
    lastSegmentStart=null;
});

document.addEventListener("keydown",e=>{
    if(e.code==="Space" && currentCircle && !isSpaceDown){
        const now = performance.now();
        segments.push({type:'gap',duration:now-lastSegmentStart});
        lastSegmentStart = now;
        isSpaceDown=true;
        e.preventDefault();
    }
});

document.addEventListener("keyup",e=>{
    if(e.code==="Space" && currentCircle && isSpaceDown){
        const now = performance.now();
        segments.push({type:'dash',duration:now-lastSegmentStart});
        lastSegmentStart = now;
        isSpaceDown=false;
        e.preventDefault();
    }
});
</script>
</body>
</html>
