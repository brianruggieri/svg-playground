<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dash-Synced Audio Circles</title>
<style>
html, body {margin:0;padding:0;width:100%;height:100%;background:#111;overflow:hidden;}
svg {display:block;width:100%;height:100%;cursor:crosshair;}
.ghost {fill:none;stroke:rgba(255,255,255,0.15);stroke-width:1.5;}
.spinner {fill:none;stroke-width:8;transform-box:fill-box;transform-origin:center;}
@keyframes spin {to{transform:rotate(360deg);}}
</style>
</head>
<body>
<svg id="canvas"></svg>
<script>
const svg = document.getElementById("canvas");
const radius = 60;
const circ = 2 * Math.PI * radius;

let currentCircle = null;
let holdStart = null;
let lastSegmentStart = null;
let isSpaceDown = false;
let segments = [];
let rafId = null;
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();

// Random color generator
function randomColor(){return `hsl(${Math.floor(Math.random()*360)},80%,55%)`;}

// Build dash array string
function buildDashArray(segments,liveType,liveDuration,totalDurationMs){
    if(totalDurationMs<=0) return `0 ${circ}`;
    const scale = circ/totalDurationMs;
    const all = segments.slice();
    if(liveDuration>0) all.push({type:liveType,duration:liveDuration});
    if(all.length===0) return `0 ${circ}`;
    const lens=all.map(s=>Math.max(1,Math.round(s.duration*scale)));
    const out=[];
    if(all[0].type==='gap'){ out.push(0,lens[0]); for(let i=1;i<lens.length;i++) out.push(lens[i]);}
    else{for(let i=0;i<lens.length;i++) out.push(lens[i]);}
    return out.join(' ');
}

// Play a tone at an absolute AudioContext time
function playToneAtTime(freq, pan, duration, modDepth, modRate, startTime){
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    const panner = audioCtx.createStereoPanner();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gainNode.gain.value = 0.2;
    panner.pan.value = pan;
    osc.connect(gainNode); gainNode.connect(panner); panner.connect(audioCtx.destination);

    if(modDepth>0){
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();
        lfo.frequency.value = modRate;
        lfoGain.gain.value = modDepth;
        lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
        lfo.start(startTime);
        osc.onended = ()=>lfo.stop();
    }

    osc.start(startTime);
    osc.stop(startTime + duration);
}

// Live preview tick
function startLivePreview(){
    const tick = () => {
        if(!currentCircle) return;
        const now = performance.now();
        const liveDuration= lastSegmentStart ? now - lastSegmentStart : 0;
        const total=now-holdStart;
        const dashArray=buildDashArray(segments,isSpaceDown?'dash':'gap',liveDuration,total);
        currentCircle.setAttribute('stroke-dasharray',dashArray);
        currentCircle.setAttribute('stroke-dashoffset',0.5);

        // Play live tone if spacebar held
        if(isSpaceDown && liveDuration>0){
            const x=currentCircle._pos.x;
            const y=currentCircle._pos.y;
            const freq=220 + (x/window.innerWidth)*880 + (Math.random()*20-10);
            const pan=(x/window.innerWidth)*2-1;
            const modDepth=5 + (y/window.innerHeight)*20;
            const modRate=2 + (y/window.innerHeight)*3;
            playToneAtTime(freq, pan, 0.05, modDepth, modRate, audioCtx.currentTime);
        }

        rafId = requestAnimationFrame(tick);
    };
    rafId = requestAnimationFrame(tick);
}

// Dash-length-synced audio loop using absolute time
function loopCircleAudio(circle){
    const rotationPeriod = 2;
    const radius = parseFloat(circle.getAttribute('r'));
    const circumference = 2 * Math.PI * radius;

    function scheduleLoopAhead(){
        const dashArray = circle.getAttribute('stroke-dasharray').split(' ').map(Number);
        const totalLength = dashArray.reduce((a,b)=>a+b,0);
        const segments = dashArray.map((length,i)=>({type: i%2===0?'dash':'gap', length}));

        let t = audioCtx.currentTime + 0.05;
        segments.forEach(seg=>{
            const dur = (seg.length/totalLength)*rotationPeriod;
            if(seg.type==='dash' && dur>0){
                const x = circle._pos.x;
                const y = circle._pos.y;
                const freq = 220 + (x/window.innerWidth)*880 + (Math.random()*20-10);
                const pan = (x/window.innerWidth)*2-1;
                const modDepth = 5 + (y/window.innerHeight)*20;
                const modRate = 2 + (y/window.innerHeight)*3;
                playToneAtTime(freq, pan, dur, modDepth, modRate, t);
            }
            t += dur;
        });

        setTimeout(scheduleLoopAhead, (rotationPeriod-0.05)*1000);
    }

    scheduleLoopAhead();
}

// Mouse events
svg.addEventListener("mousedown", e=>{
    const pt=svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
    const loc=pt.matrixTransform(svg.getScreenCTM().inverse());

    // Ghost outline
    const ghost=document.createElementNS("http://www.w3.org/2000/svg","circle");
    ghost.setAttribute("cx",loc.x); ghost.setAttribute("cy",loc.y); ghost.setAttribute("r",radius);
    ghost.classList.add("ghost"); svg.appendChild(ghost);

    // Current circle
    currentCircle=document.createElementNS("http://www.w3.org/2000/svg","circle");
    currentCircle.setAttribute("cx",loc.x); currentCircle.setAttribute("cy",loc.y); currentCircle.setAttribute("r",radius);
    currentCircle.classList.add("spinner");
    currentCircle.style.stroke=randomColor();
    currentCircle.setAttribute('stroke-dasharray', `0 ${circ}`); // start fully empty
    currentCircle.setAttribute('stroke-dashoffset',0.5);
    currentCircle._pos={x:loc.x,y:loc.y};
    svg.appendChild(currentCircle);

    holdStart=performance.now();
    lastSegmentStart=holdStart;
    segments=[];
    isSpaceDown=false;
    startLivePreview();
});

svg.addEventListener("mouseup", ()=>{
    if(!currentCircle) return;
    const now=performance.now();
    segments.push({type:isSpaceDown?'dash':'gap',duration:now-lastSegmentStart});
    const total=now-holdStart;
    const dashArray=buildDashArray(segments,null,0,total);
    currentCircle.setAttribute('stroke-dasharray', dashArray);
    currentCircle.setAttribute('stroke-dashoffset',0.5);
    currentCircle.style.animation='spin 2s linear infinite';

    currentCircle._segments=segments.slice();
    currentCircle._holdDuration=total;
    loopCircleAudio(currentCircle);

    cancelAnimationFrame(rafId);
    currentCircle=null;
    segments=[];
    isSpaceDown=false;
    holdStart=null;
    lastSegmentStart=null;
});

// Spacebar events
document.addEventListener("keydown", e=>{
    if(e.code==="Space" && currentCircle && !isSpaceDown){
        const now = performance.now();
        segments.push({type:'gap',duration:now-lastSegmentStart});
        lastSegmentStart=now;
        isSpaceDown=true;
        e.preventDefault();
    }
});

document.addEventListener("keyup", e=>{
    if(e.code==="Space" && currentCircle && isSpaceDown){
        const now=performance.now();
        segments.push({type:'dash',duration:now-lastSegmentStart});
        lastSegmentStart=now;
        isSpaceDown=false;
        e.preventDefault();
    }
});
</script>
</body>
</html>
